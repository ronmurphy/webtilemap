<!DOCTYPE html>
<html lang="en">
 <head>
  <meta charset="utf-8"/>
  <meta content="width=device-width, initial-scale=1.0" name="viewport"/>
  <title>
   TileMap Studio
  </title>
  <link href="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/css/materialize.min.css" rel="stylesheet"/>
  <link href="https://fonts.googleapis.com/icon?family=Material+Icons" rel="stylesheet"/>
  <style>
   body, html {
            margin: 0;
            padding: 0;
            height: 100%;
            overflow: hidden;
        }
        #app {
            display: flex;
            height: 100vh;
        }
        #toolbox {
            width: 60px;
            background-color: #f5f5f5;
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        #canvas-container {
            flex-grow: 1;
            position: relative;
            overflow: hidden;
        }
        #main-canvas {
            position: absolute;
            top: 0;
            left: 0;
        }
        .tool-button {
            margin-bottom: 10px;
            cursor: pointer;
            padding: 5px;
            border-radius: 5px;
        }
        .tool-button.active {
            background-color: #e0e0e0;
        }
        #layer-panel {
            width: 250px;
            background-color: #f5f5f5;
            padding: 10px;
            display: flex;
            flex-direction: column;
            /* for the debuglabel */
            position: relative;
            padding-bottom: 20px; /* add some padding to make room for the debug label */
        }
        .layer {
            margin-bottom: 5px;
            padding: 5px;
            background-color: #fff;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
        }
        .active-layer {
            background-color: #e0e0e0;
        }
        .layer-name {
            flex-grow: 1;
        }
        .layer-visibility, .layer-lock, .layer-move {
            cursor: pointer;
            margin-left: 5px;
        }
        #sprite-list {
            max-height: 200px;
            overflow-y: auto;
            margin-bottom: 10px;
            background-color: #fff;
            border: 1px solid #ddd;
            padding: 10px;
        }
        .sprite-item {
            display: inline-block;
            margin: 5px;
            cursor: pointer;
            transition: transform 0.1s;
        }
        .sprite-item:hover {
            transform: scale(1.1);
        }
        #spritesheet-dialog {
            display: none;
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            padding: 20px;
            border: 1px solid black;
            z-index: 1000;
            max-width: 90vw;
            max-height: 90vh;
            overflow: auto;
        }
        .context-menu {
            position: fixed;
            background: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.1);
            z-index: 1000;
        }
        .context-menu-item {
            padding: 8px 12px;
            cursor: pointer;
        }
        .context-menu-item:hover {
            background-color: #f0f0f0;
        }
        #spritesheet-container {
            position: relative;
            overflow: hidden;
            max-width: 100%;
            max-height: 70vh;
        }
        #spritesheet-img {
            max-width: none;
            max-height: none;
        }
        #torch-btn {
            color: #FF4500;
        }
        #tile-chooser {
            display: block !important;
        }
        #tile-chooser select {
            display: block;
            width: 100%;
            margin-bottom: 10px;
        }
        .tile-selector-row {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .tile-selector {
            flex: 1 1 auto;
            min-width: 120px;
            margin: 0 10px 20px;
            text-align: center;
        }
        .tile-carousel {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tile-preview {
            width: 64px;
            height: 64px;
            border: 1px solid #ccc;
            margin: 0 5px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tile-preview img {
            max-width: 100%;
            max-height: 100%;
            image-rendering: pixelated;
        }
        .prev-tile, .next-tile {
            background: #f0f0f0;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
        }
        @media (max-width: 600px) {
            .tile-selector {
                flex-basis: 100%;
            }
        }
        .highlight {
          background-color: rgba(255, 255, 0, 0.5);
          border: 1px solid #fff;
        }
        .grid {
          position: absolute;
          top: 0;
          left: 0;
          width: 100%;
          height: 100%;
          z-index: -1;
          opacity: 0;
          pointer-events: none;
        }
        #debug-label {
          position: absolute;
          bottom: 0;
          left: 0;
          width: 100%;
          background-color: #f0f0f0;
          padding: 5px;
          border-top: 1px solid #ccc;
        }
  </style>
 </head>
 <body>
  <div class="grid" id="grid-32">
  </div>
  <div id="app">
   <div id="toolbox">
    <i class="material-icons tool-button" data-tool="select" title="Select Tool">
     pan_tool_alt
    </i>
    <i class="material-icons tool-button" data-tool="hand" title="Move Tool">
     pan_tool
    </i>
    <i class="material-icons tool-button" data-tool="marquee" title="Marquee Tool">
     crop_square
    </i>
    <i class="material-icons tool-button" data-tool="brush" title="Brush Tool">
     brush
    </i>
    <i class="material-icons tool-button" data-tool="eraser" title="Eraser Tool">
     remove_circle_outline
    </i>
    <i class="material-icons tool-button" data-tool="fill" title="Fill Tool">
     format_color_fill
    </i>
    <i class="material-icons tool-button" data-tool="text" title="Text Tool">
     text_fields
    </i>
    <i class="material-icons tool-button" data-tool="eyedropper" title="Eyedropper Tool">
     colorize
    </i>
    <i class="material-icons tool-button" data-tool="zoom" title="Zoom Tool">
     zoom_in
    </i>
    <i class="material-icons tool-button" data-tool="torch" id="torch-btn" title="Torch Tool">
     whatshot
    </i>
    <i class="material-icons tool-button" id="settings-btn" title="Settings">
     settings
    </i>
    <i class="material-icons tool-button" id="help-btn" title="Help">
     help_outline
    </i>
    <i class="material-icons tool-button" id="undo-btn" title="Undo">
     undo
    </i>
    <i class="material-icons tool-button" id="redo-btn" title="Redo">
     redo
    </i>
   </div>
   <div id="canvas-container">
    <canvas id="main-canvas">
    </canvas>
   </div>
   <div id="layer-panel">
    <button class="btn waves-effect waves-light" id="spritesheet-btn">
     Load Spritesheet
    </button>
    <div id="sprite-list">
    </div>
    <h6>
     Layers
    </h6>
    <div id="layer-list">
    </div>
    <button class="btn waves-effect waves-light" id="save-tilesheet-btn">
     Save Sliced Tilesheet
    </button>
    <button class="btn waves-effect waves-light" id="load-tilesheet-btn">
     Load Sliced Tilesheet
    </button>
    <button class="btn waves-effect waves-light" id="add-layer-btn">
     Add Layer
    </button>
    <button class="btn waves-effect waves-light" id="save-btn">
     Save
    </button>
    <button class="btn waves-effect waves-light" id="load-btn">
     Load
    </button>
    <div id="debug-label">
    </div>
   </div>
  </div>
  <!-- <div id="spritesheet-dialog">
        <div id="spritesheet-container">
            <img id="spritesheet-img">
            <canvas id="spritesheet-grid"></canvas>
        </div>
        <div>
            <label for="sprite-width">Sprite Width:</label>
            <input type="number" id="sprite-width" min="1" value="32">
            <label for="sprite-height">Sprite Height:</label>
            <input type="number" id="sprite-height" min="1" value="32">
        </div>
        <div>
            <label for="grid-offset-x">Grid Offset X:</label>
            <input type="number" id="grid-offset-x" value="0">
            <label for="grid-offset-y">Grid Offset Y:</label>
            <input type="number" id="grid-offset-y" value="0">
        </div>
        <button id="spritesheet-ok" class="btn waves-effect waves-light">OK</button>
    </div> -->
  <div id="spritesheet-dialog">
   <div id="spritesheet-container">
    <img id="spritesheet-img"/>
    <canvas id="spritesheet-grid">
    </canvas>
   </div>
   <div style="display: flex; flex-direction: row; justify-content: space-between; align-items: center;">
    <div>
     <label for="sprite-width">
      Sprite Width:
     </label>
     <input id="sprite-width" min="1" type="number" value="32"/>
    </div>
    <div>
     <label for="sprite-height">
      Sprite Height:
     </label>
     <input id="sprite-height" min="1" type="number" value="32"/>
    </div>
    <div>
     <label for="tile-count-width">
      Tiles in Width:
     </label>
     <input id="tile-count-width" min="1" type="number" value="1"/>
    </div>
    <div>
     <label for="tile-count-height">
      Tiles in Height:
     </label>
     <input id="tile-count-height" min="1" type="number" value="1"/>
    </div>
    <div>
     <label for="grid-offset-x">
      Grid Offset X:
     </label>
     <input id="grid-offset-x" type="number" value="0"/>
    </div>
    <div>
     <label for="grid-offset-y">
      Grid Offset Y:
     </label>
     <input id="grid-offset-y" type="number" value="0"/>
    </div>
   </div>
   <div style="text-align: right; padding-top: 10px;">
    <button class="btn waves-effect waves-light" id="spritesheet-ok">
     OK
    </button>
   </div>
  </div>
  <div class="modal" id="help-modal">
   <div class="modal-content">
    <h4>
     TileMap Studio Help
    </h4>
    <p>
     Welcome to TileMap Studio! Here's a quick guide to get you started:
    </p>
    <ul>
     <li>
      <strong>
       Select Tool:
      </strong>
      Click to select and move tiles on the canvas.
     </li>
     <li>
      <strong>
       Move Tool:
      </strong>
      Click and drag to move the canvas view.
     </li>
     <li>
      <strong>
       Marquee Tool:
      </strong>
      Click and drag to select multiple tiles.
     </li>
     <li>
      <strong>
       Brush Tool:
      </strong>
      Click and drag to paint with the selected sprite.
     </li>
     <li>
      <strong>
       Eraser Tool:
      </strong>
      Click and drag to remove tiles.
     </li>
     <li>
      <strong>
       Fill Tool:
      </strong>
      Click to fill an area with the selected sprite.
     </li>
     <li>
      <strong>
       Text Tool:
      </strong>
      Click to add text to the canvas.
     </li>
     <li>
      <strong>
       Eyedropper Tool:
      </strong>
      Click to select a tile on the canvas.
     </li>
     <li>
      <strong>
       Zoom Tool:
      </strong>
      Click to zoom in, right-click to zoom out.
     </li>
     <li>
      <strong>
       Hand Tool:
      </strong>
      Click and drag to pan the canvas view.
     </li>
     <li>
      <strong>
       Torch Tool:
      </strong>
      Click to place a light source on the map.
     </li>
     <li>
      <strong>
       Settings:
      </strong>
      Adjust grid size and other options.
     </li>
     <li>
      <strong>
       Load Spritesheet:
      </strong>
      Import a spritesheet to use for tiles.
     </li>
     <li>
      <strong>
       Layers:
      </strong>
      Manage different layers of your map.
     </li>
     <li>
      <strong>
       Save/Load:
      </strong>
      Save your work or load a previous project.
     </li>
    </ul>
    <p>
     Double-click on a tile to open the context menu for additional options.
    </p>
   </div>
   <div class="modal-footer">
    <a class="modal-close waves-effect waves-green btn-flat" href="#!">
     Close
    </a>
   </div>
  </div>
  // end part 1 ...
  <script src="https://cdnjs.cloudflare.com/ajax/libs/materialize/1.0.0/js/materialize.min.js">
  </script>
  <script>
   document.addEventListener('DOMContentLoaded', function() {
        // Canvas and context setup
        const canvas = document.getElementById('main-canvas');
        const ctx = canvas.getContext('2d');
        const layerList = document.getElementById('layer-list');
        const spriteList = document.getElementById('sprite-list');
        const MAX_HISTORY = 50;
let undoStack = [];
let redoStack = [];
let isUndoRedoAction = false;

        // Initialize layers
        let layers = [
    { name: 'Blueprints', color: 'blue', visible: true, locked: false, items: [], order: 0 },
    { name: 'Background', color: 'green', visible: true, locked: false, items: [], order: 1 },
    { name: 'Tiles', color: 'black', visible: true, locked: false, items: [], order: 2 },
    { name: 'Assets', color: 'yellow', visible: true, locked: false, items: [], order: 3 },
    { name: 'Fog', color: 'grey', visible: false, locked: false, items: [], order: 4 }
];

        // Global variables
        let activeLayerIndex = 2;
        let activeTool = 'select';
        let gridSize = 32;
        let zoomLevel = 1;
        let panOffset = { x: 0, y: 0 };
        let sprites = [];
        let activeSprite = null;
        let selectedTile = null;
        let isDragging = false;
        let lastX, lastY;
        let spritesheetZoom = 1;
let spritesheetPan = { x: 0, y: 0 };
let isDraggingSpritesheet = false;
let lastSpritesheetX, lastSpritesheetY;
        let gridOffset = { x: 0, y: 0 };
        let lightSources = [];
        let marqueeStart = null;
        let marqueeEnd = null;
        let selectedTiles = [];
        let useOpacityForHiddenLayers = true;
        let JSZip;
        let jsZipLoaded = false;
        let lightSourcesAbsolute = [];

        const gridId = `grid-${gridSize}`;

        

        function init() {
  resizeCanvas();
  updateLayerList();
  updateToolHighlight();
  addDungeonGenerationButton();

  // Load JSZip library dynamically
  const script = document.createElement('script');
script.src = 'https://cdnjs.cloudflare.com/ajax/libs/jszip/3.7.1/jszip.min.js';
  script.onload = function() {
    window.JSZip = JSZip;
    console.log('JSZip loaded successfully');
    jsZipLoaded = true;
    bindEventListeners();
  };
  script.onerror = function() {
    console.error('Failed to load JSZip');
  };
  document.head.appendChild(script);

  // Ensure bindEventListeners is called after a short delay to allow DOM to be fully ready
  setTimeout(bindEventListeners, 100);
}

document.addEventListener('DOMContentLoaded', init);
        // Core functions
        function resizeCanvas() {
            canvas.width = canvas.parentElement.clientWidth;
            canvas.height = canvas.parentElement.clientHeight;
            
            redrawCanvas();
        }

        function redrawCanvas() {
    updatePanAndZoom();
    ctx.clearRect(0, 0, canvas.width, canvas.height);
   
    ctx.save();
    ctx.translate(panOffset.x, panOffset.y);
    ctx.scale(zoomLevel, zoomLevel);

    drawGrid();

    layers.sort((a, b) => a.order - b.order).forEach((layer, index) => {
        if (useOpacityForHiddenLayers || layer.visible) {
            ctx.save();
            if (!layer.visible) {
                ctx.globalAlpha = 0.3;
            }
            layer.items.forEach(item => {
                if (item && item.image) {
                    if (item.image instanceof HTMLCanvasElement) {
                        ctx.drawImage(item.image, item.x, item.y);
                    } else if (item.image instanceof HTMLImageElement && item.image.complete) {
                        ctx.drawImage(item.image, item.x, item.y);
                    }
                   
                    if (selectedTile === item) {
                        ctx.strokeStyle = 'red';
                        ctx.lineWidth = 2 / zoomLevel;
                        ctx.strokeRect(item.x, item.y, item.image.width, item.image.height);
                    }
                }
            });
            ctx.restore();
        }
    });

    ctx.restore();

    drawLighting();

    ctx.save();
    ctx.translate(panOffset.x, panOffset.y);
    ctx.scale(zoomLevel, zoomLevel);

    if (marqueeStart && marqueeEnd) {
        drawMarqueeSelection();
    }

    highlightSelectedTiles();

    ctx.restore();
}

function drawTilePlacementPreview(pos) {
    const snappedPos = snapToGrid(pos.x, pos.y);
    
    ctx.save();
    ctx.translate(panOffset.x, panOffset.y);
    ctx.scale(zoomLevel, zoomLevel);

    // Draw current tile preview (red)
    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
    ctx.lineWidth = 2 / zoomLevel;
    ctx.strokeRect(snappedPos.x, snappedPos.y, gridSize, gridSize);
    
    // Draw surrounding tiles preview (yellow)
    ctx.strokeStyle = 'rgba(255, 255, 0, 0.5)';
    ctx.lineWidth = 1 / zoomLevel;
    for (let dy = -1; dy <= 1; dy++) {
        for (let dx = -1; dx <= 1; dx++) {
            if (dx === 0 && dy === 0) continue; // Skip the center tile
            ctx.strokeRect(snappedPos.x + dx * gridSize, snappedPos.y + dy * gridSize, gridSize, gridSize);
        }
    }
    ctx.restore();
}

function updateDebugLabel(mousePos) {
    const debugLabel = document.getElementById('debug-label');
    if (debugLabel) {
        if (mousePos) {
            debugLabel.textContent = `Mouse: (${mousePos.x.toFixed(2)}, ${mousePos.y.toFixed(2)}) | Zoom: ${zoomLevel.toFixed(2)} | Tool: ${activeTool}`;
        } else {
            debugLabel.textContent = `Zoom: ${zoomLevel.toFixed(2)} | Tool: ${activeTool}`;
        }
    }
}
        function drawGrid() {
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.5)';
            ctx.lineWidth = 1 / zoomLevel;

            const startX = Math.floor(-panOffset.x / zoomLevel / gridSize) * gridSize;
            const startY = Math.floor(-panOffset.y / zoomLevel / gridSize) * gridSize;
            const endX = startX + canvas.width / zoomLevel + gridSize;
            const endY = startY + canvas.height / zoomLevel + gridSize;

            for (let x = startX; x < endX; x += gridSize) {
                ctx.beginPath();
                ctx.moveTo(x, startY);
                ctx.lineTo(x, endY);
                ctx.stroke();
            }

            for (let y = startY; y < endY; y += gridSize) {
                ctx.beginPath();
                ctx.moveTo(startX, y);
                ctx.lineTo(endX, y);
                ctx.stroke();
            }
        }

        function saveState() {
    if (isUndoRedoAction) return;
    const state = JSON.stringify(layers);
    undoStack.push(state);
    if (undoStack.length > MAX_HISTORY) {
        undoStack.shift();
    }
    redoStack = [];
}
function restoreState(state) {
    const newLayers = JSON.parse(state, (key, value) => {
        if (key === 'image' && typeof value === 'string' && value.startsWith('data:image')) {
            const img = new Image();
            img.src = value;
            const canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            const ctx = canvas.getContext('2d');
            img.onload = () => {
                ctx.drawImage(img, 0, 0);
                redrawCanvas(); // Redraw after image loads
            };
            return canvas;
        }
        return value;
    });
    layers = newLayers;
    redrawCanvas();
    updateLayerList(); // Update the layer UI
}

function undo() {
    if (undoStack.length > 0) {
        isUndoRedoAction = true;
        const currentState = JSON.stringify(layers);
        redoStack.push(currentState);
        const previousState = undoStack.pop();
        layers = JSON.parse(previousState);
        updateLayerList();
        redrawCanvas();
        isUndoRedoAction = false;
    }
}

function redo() {
    if (redoStack.length > 0) {
        isUndoRedoAction = true;
        const currentState = JSON.stringify(layers);
        undoStack.push(currentState);
        const nextState = redoStack.pop();
        layers = JSON.parse(nextState);
        updateLayerList();
        redrawCanvas();
        isUndoRedoAction = false;
    }
}

        function drawLighting() {
    const fogLayer = layers.find(layer => layer.name === 'Fog');
    if (!fogLayer || !fogLayer.visible) return;

    const fogCanvas = document.createElement('canvas');
    fogCanvas.width = canvas.width;
    fogCanvas.height = canvas.height;
    const fogCtx = fogCanvas.getContext('2d');

    // Fill with almost black color (back to original opacity)
    fogCtx.fillStyle = 'rgba(0, 0, 0, 0.9)';
    fogCtx.fillRect(0, 0, fogCanvas.width, fogCanvas.height);

    fogCtx.save();
    fogCtx.scale(zoomLevel, zoomLevel);
    fogCtx.translate(panOffset.x / zoomLevel, panOffset.y / zoomLevel);

    lightSources.forEach(light => {
        const radius = 5 * gridSize;
        const lightX = light.x;
        const lightY = light.y;

        const gradient = fogCtx.createRadialGradient(lightX, lightY, 0, lightX, lightY, radius);
        gradient.addColorStop(0, 'rgba(255, 255, 255, 1)');
        gradient.addColorStop(1, 'rgba(255, 255, 255, 0)');

        fogCtx.globalCompositeOperation = 'destination-out';
        fogCtx.fillStyle = gradient;
        fogCtx.beginPath();
        fogCtx.arc(lightX, lightY, radius, 0, Math.PI * 2);
        fogCtx.fill();

        // Cast shadows (if you want to keep this feature)
        for (let angle = 0; angle < Math.PI * 2; angle += 0.1) {
            castRay(fogCtx, light, angle, radius);
        }
    });

    fogCtx.restore();

    ctx.drawImage(fogCanvas, 0, 0);
}

function castRay(fogCtx, light, angle, maxDistance) {
    const rayX = Math.cos(angle);
    const rayY = Math.sin(angle);
    let distance = 0;

    while (distance < maxDistance) {
        const x = light.x + rayX * distance;
        const y = light.y + rayY * distance;

        if (isTileAtPosition(x, y)) {
            // Draw shadow
            fogCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            fogCtx.beginPath();
            fogCtx.moveTo(light.x, light.y);
            fogCtx.lineTo(x, y);
            fogCtx.lineTo(x + rayX * (maxDistance - distance), y + rayY * (maxDistance - distance));
            fogCtx.closePath();
            fogCtx.fill();
            break;
        }

        distance += gridSize / 2;
    }
}

function isTileAtPosition(x, y) {
    for (let i = layers.length - 1; i >= 0; i--) {
        const layer = layers[i];
        if (layer.name === 'Fog') continue;
        for (let j = 0; j < layer.items.length; j++) {
            const item = layer.items[j];
            if (x >= item.x && x < item.x + item.image.width &&
                y >= item.y && y < item.y + item.image.height) {
                return true;
            }
        }
    }
    return false;
}
    
function validatePanAndZoom() {
    panOffset.x = isFinite(panOffset.x) ? panOffset.x : 0;
    panOffset.y = isFinite(panOffset.y) ? panOffset.y : 0;
    zoomLevel = isFinite(zoomLevel) && zoomLevel > 0 ? zoomLevel : 1;
}

function updatePanAndZoom() {
    validatePanAndZoom();
    // zoomLevel = Math.max(0.1, Math.min(10, zoomLevel)); // Ensure zoom is never 0 and has reasonable limits
    zoomLevel = Math.min(Math.max(zoomLevel, 0.1), 10);
    // Optionally, add constraints to pan and zoom here
    // For example:
    // panOffset.x = Math.max(-1000, Math.min(1000, panOffset.x));
    // panOffset.y = Math.max(-1000, Math.min(1000, panOffset.y));
    // zoomLevel = Math.max(0.1, Math.min(10, zoomLevel));
}

// When adding a new light source
// lightSourcesAbsolute.push({ x: absoluteX, y: absoluteY });

function updateLayerList() {
    layerList.innerHTML = '';
    layers.sort((a, b) => b.order - a.order).forEach((layer, index) => {
        const layerDiv = document.createElement('div');
        layerDiv.className = `layer ${index === activeLayerIndex ? 'active-layer' : ''}`;
        layerDiv.innerHTML = `
            <span class="layer-name" style="color: ${layer.color}">${layer.name}</span>
            <i class="material-icons layer-visibility">${layer.visible ? 'visibility' : 'visibility_off'}</i>
            <i class="material-icons layer-lock">${layer.locked ? 'lock' : 'lock_open'}</i>
            ${layer.order < layers.length - 1 ? '<i class="material-icons layer-move" data-direction="down">arrow_downward</i>' : ''}
            ${layer.order > 0 ? '<i class="material-icons layer-move" data-direction="up">arrow_upward</i>' : ''}
        `;
        layerDiv.querySelector('.layer-name').addEventListener('click', () => setActiveLayer(layers.length - 1 - index));
        layerDiv.querySelector('.layer-visibility').addEventListener('click', () => toggleLayerVisibility(layers.length - 1 - index));
        layerDiv.querySelector('.layer-lock').addEventListener('click', () => toggleLayerLock(layers.length - 1 - index));
        const moveButtons = layerDiv.querySelectorAll('.layer-move');
        moveButtons.forEach(button => {
            button.addEventListener('click', (e) => moveLayer(layers.length - 1 - index, e.target.dataset.direction));
        });
        layerList.appendChild(layerDiv);
    });
}

        function setActiveLayer(index) {
    activeLayerIndex = index;
    updateLayerList();
    redrawCanvas(); // Ensure the canvas reflects the new active layer
}

        function toggleLayerVisibility(index) {
            layers[index].visible = !layers[index].visible;
            updateLayerList();
            redrawCanvas();
        }

        function toggleLayerLock(index) {
            layers[index].locked = !layers[index].locked;
            updateLayerList();
        }

        function moveLayer(index, direction) {
    const layer = layers[index];
    if (direction === 'up' && layer.order < layers.length - 1) {
        const upperLayer = layers.find(l => l.order === layer.order + 1);
        upperLayer.order--;
        layer.order++;
    } else if (direction === 'down' && layer.order > 0) {
        const lowerLayer = layers.find(l => l.order === layer.order - 1);
        lowerLayer.order++;
        layer.order--;
    }
    layers.sort((a, b) => a.order - b.order);
    updateLayerList();
    redrawCanvas();
}

        // More functions will follow in the next part...

        function initSpritesheetZoom() {
    const container = document.getElementById('spritesheet-container');
    
    container.addEventListener('wheel', function(event) {
        event.preventDefault();
        const rect = container.getBoundingClientRect();
        const mouseX = event.clientX - rect.left;
        const mouseY = event.clientY - rect.top;

        const zoom = event.deltaY > 0 ? 0.9 : 1.1;
        spritesheetZoom *= zoom;

        spritesheetPan.x = mouseX - (mouseX - spritesheetPan.x) * zoom;
        spritesheetPan.y = mouseY - (mouseY - spritesheetPan.y) * zoom;

        updateSpritesheetView();
        drawSpritesheetGrid();
    });

    container.addEventListener('mousedown', function(event) {
        isDraggingSpritesheet = true;
        lastSpritesheetX = event.clientX;
        lastSpritesheetY = event.clientY;
    });

    container.addEventListener('mousemove', function(event) {
        if (isDraggingSpritesheet) {
            const deltaX = event.clientX - lastSpritesheetX;
            const deltaY = event.clientY - lastSpritesheetY;
            spritesheetPan.x += deltaX;
            spritesheetPan.y += deltaY;
            lastSpritesheetX = event.clientX;
            lastSpritesheetY = event.clientY;
            updateSpritesheetView();
            drawSpritesheetGrid();
        }
    });

    container.addEventListener('mouseup', function() {
        isDraggingSpritesheet = false;
    });

    container.addEventListener('mouseleave', function() {
        isDraggingSpritesheet = false;
    });
}
function handleSpritesheet() {
    const input = document.createElement('input');
    input.type = 'file';
    input.accept = 'image/*';
    input.onchange = function(event) {
        const file = event.target.files[0];
        const reader = new FileReader();
        reader.onload = function(e) {
            const img = document.getElementById('spritesheet-img');
            img.src = e.target.result;
            img.onload = function() {
                document.getElementById('spritesheet-dialog').style.display = 'block';
                spritesheetZoom = 1;
                spritesheetPan = { x: 0, y: 0 };
                updateSpritesheetView();
                drawSpritesheetGrid();
                initSpritesheetZoom();  // Call this function here
            };
        };
        reader.readAsDataURL(file);
    };
    input.click();
}

        function updateSpritesheetView() {
            const img = document.getElementById('spritesheet-img');
            img.style.transform = `scale(${spritesheetZoom}) translate(${spritesheetPan.x}px, ${spritesheetPan.y}px)`;
        }

        function drawSpritesheetGrid() {
    const img = document.getElementById('spritesheet-img');
    const canvas = document.getElementById('spritesheet-grid');
    const ctx = canvas.getContext('2d');
    const width = parseInt(document.getElementById('sprite-width').value);
    const height = parseInt(document.getElementById('sprite-height').value);
    const tileCountWidth = parseInt(document.getElementById('tile-count-width').value);
    const tileCountHeight = parseInt(document.getElementById('tile-count-height').value);

    canvas.width = img.width;
    canvas.height = img.height;
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = '#00FF00';
    ctx.lineWidth = 1 / spritesheetZoom;

    ctx.save();
    ctx.scale(spritesheetZoom, spritesheetZoom);
    ctx.translate(spritesheetPan.x / spritesheetZoom, spritesheetPan.y / spritesheetZoom);

    const offsetX = parseInt(document.getElementById('grid-offset-x').value) || 0;
    const offsetY = parseInt(document.getElementById('grid-offset-y').value) || 0;

    const totalWidth = width * tileCountWidth;
    const totalHeight = height * tileCountHeight;

    for (let x = offsetX; x <= offsetX + totalWidth; x += width) {
        ctx.beginPath();
        ctx.moveTo(x, offsetY);
        ctx.lineTo(x, offsetY + totalHeight);
        ctx.stroke();
    }
    for (let y = offsetY; y <= offsetY + totalHeight; y += height) {
        ctx.beginPath();
        ctx.moveTo(offsetX, y);
        ctx.lineTo(offsetX + totalWidth, y);
        ctx.stroke();
    }

    ctx.restore();
}

function sliceSpritesheet() {
    spritesheetZoom = 1;
    spritesheetPan = { x: 0, y: 0 };
    updateSpritesheetView();

    const img = document.getElementById('spritesheet-img');
    const width = parseInt(document.getElementById('sprite-width').value);
    const height = parseInt(document.getElementById('sprite-height').value);
    const tileCountWidth = parseInt(document.getElementById('tile-count-width').value);
    const tileCountHeight = parseInt(document.getElementById('tile-count-height').value);
    const offsetX = parseInt(document.getElementById('grid-offset-x').value) || 0;
    const offsetY = parseInt(document.getElementById('grid-offset-y').value) || 0;
    const filename = img.src.split('/').pop().split('.')[0].substring(0, 10);


    sprites = [];
    for (let y = 0; y < tileCountHeight; y++) {
        for (let x = 0; x < tileCountWidth; x++) {
            const canvas = document.createElement('canvas');
            canvas.width = width;
            canvas.height = height;
            const ctx = canvas.getContext('2d');
            ctx.drawImage(img, 
                offsetX + x * width, offsetY + y * height, width, height, 
                0, 0, width, height
            );
            sprites.push({
                name: `${filename}-${sprites.length}`,
                image: canvas
            });
        }
    }
    



function updateSpritesheetView() {
    const img = document.getElementById('spritesheet-img');
    img.style.transform = `scale(${spritesheetZoom}) translate(${spritesheetPan.x / spritesheetZoom}px, ${spritesheetPan.y / spritesheetZoom}px)`;
}



    document.getElementById('spritesheet-dialog').style.display = 'none';
    updateSpriteList();
}
function updateSpriteList() {
    spriteList.innerHTML = '';
    sprites.forEach((sprite, index) => {
        const spriteElement = document.createElement('div');
        spriteElement.className = 'sprite-item';
        spriteElement.innerHTML = `<img src="${sprite.image.toDataURL()}" title="${sprite.name}">`;
        spriteElement.addEventListener('click', () => {
            activeSprite = sprite;
            activeTool = 'brush';
            updateToolHighlight();
            console.log('Active sprite set:', activeSprite); // Debug log
        });
        spriteList.appendChild(spriteElement);
    });
}

        function updateToolHighlight() {
            document.querySelectorAll('.tool-button').forEach(button => {
                button.classList.remove('active');
                if (button.getAttribute('data-tool') === activeTool) {
                    button.classList.add('active');
                }
            });
        }

        function snapToGrid(x, y) {
            return {
                x: Math.round(x / gridSize) * gridSize,
                y: Math.round(y / gridSize) * gridSize
            };
        }

        function getMousePos(event) {
    if (!event) {
        return null;
    }
    const rect = canvas.getBoundingClientRect();
    return {
        x: (event.clientX - rect.left - panOffset.x) / zoomLevel,
        y: (event.clientY - rect.top - panOffset.y) / zoomLevel
    };
}

        function getRandomColor() {
            const letters = '0123456789ABCDEF';
            let color = '#';
            for (let i = 0; i < 6; i++) {
                color += letters[Math.floor(Math.random() * 16)];
            }
            return color;
        }

        // Event Listeners
        canvas.addEventListener('mousedown', function(event) {
            const pos = getMousePos(event);
            lastX = event.clientX;
            lastY = event.clientY;
            isDragging = true;

            switch (activeTool) {
                case 'eraser':
                    handleEraserTool(event);
                    break;
                case 'brush':
                if (activeSprite) {
                const snappedPos = snapToGrid(pos.x, pos.y);
                placeTile(snappedPos.x, snappedPos.y);
                redrawCanvas();
            }
                    break;
                case 'select':
                    selectedTile = findClickedTile(pos);
                    if (selectedTile) {
                        offsetX = pos.x - selectedTile.item.x;
                        offsetY = pos.y - selectedTile.item.y;
                    }
                    break;
                case 'move':
                    panStartX = event.clientX - panOffset.x;
                    panStartY = event.clientY - panOffset.y;
                    break;
                case 'marquee':
                    marqueeStart = pos;
                    marqueeEnd = pos;
                    selectedTiles = []; // Clear previous selection
                    break;
                case 'fill':
                    if (activeSprite) {
                        floodFill(pos.x, pos.y);
                    }
                    break;
                case 'eyedropper':
                    const pickedTile = findClickedTile(pos);
                    if (pickedTile) {
                        activeSprite = { image: pickedTile.item.image };
                        activeTool = 'brush'; // Switch to brush after picking a color
                        updateToolHighlight();
                    }
                    break;
                case 'hand':
                    panStartX = event.clientX - panOffset.x;
                    panStartY = event.clientY - panOffset.y;
                    break;
                case 'torch':
                    // placeLightSource(pos);
                    const snappedPos = snapToGrid(pos.x, pos.y);
        lightSources.push({ x: snappedPos.x + gridSize / 2, y: snappedPos.y + gridSize / 2 });
        redrawCanvas();
                    break;
            }
        });

     

        canvas.addEventListener('mousemove', function(event) {
    const pos = getMousePos(event);
    updateDebugLabel(event);

    // Clear previous drawings and redraw the canvas
    redrawCanvas();

    // Draw tile placement preview if brush tool is active
    if (activeTool === 'brush' && activeSprite) {
        drawTilePlacementPreview(pos);
    }

    if (isDragging) {
        const deltaX = event.clientX - lastX;
        const deltaY = event.clientY - lastY;

        switch (activeTool) {
            case 'hand':
                panOffset.x += deltaX;
                panOffset.y += deltaY;
                redrawCanvas(); // Redraw after panning
                break;
            case 'select':
                if (selectedTile) {
                    selectedTile.x += deltaX / zoomLevel;
                    selectedTile.y += deltaY / zoomLevel;
                    redrawCanvas(); // Redraw to update tile position
                    
                    // Draw snap position indicator
                    const snappedPos = snapToGrid(selectedTile.x, selectedTile.y);
                    ctx.save();
                    ctx.translate(panOffset.x, panOffset.y);
                    ctx.scale(zoomLevel, zoomLevel);
                    ctx.setLineDash([5, 5]);
                    ctx.strokeStyle = 'rgba(255, 0, 0, 0.5)';
                    ctx.strokeRect(snappedPos.x, snappedPos.y, selectedTile.image.width, selectedTile.image.height);
                    ctx.restore();
                }
                break;
            case 'brush':
                if (activeSprite) {
                    const snappedPos = snapToGrid(pos.x, pos.y);
                    placeTile(snappedPos.x, snappedPos.y);
                    redrawCanvas(); // Redraw after placing tile
                }
                break;
            case 'eraser':
                handleEraserTool(event);
                redrawCanvas(); // Redraw after erasing
                break;
            case 'marquee':
                marqueeEnd = pos;
                redrawCanvas(); // Redraw to update marquee selection
                break;
            case 'fill':
                // Fill tool typically doesn't do anything on mousemove
                break;
            case 'eyedropper':
                // Eyedropper typically doesn't do anything on mousemove
                break;
            case 'zoom':
                // Zoom typically doesn't do anything on mousemove
                break;
            case 'torch':
                // Torch typically doesn't do anything on mousemove
                break;
        }

        lastX = event.clientX;
        lastY = event.clientY;
    }

    // Always draw the tile placement preview if brush tool is active, even when not dragging
    if (activeTool === 'brush' && activeSprite) {
        drawTilePlacementPreview(pos);
    }
});

function updateDebugLabel(event) {
    const mousePos = getMousePos(event);
    const debugLabel = document.getElementById('debug-label');
    if (debugLabel && mousePos) {
        debugLabel.textContent = `Mouse: (${mousePos.x.toFixed(2)}, ${mousePos.y.toFixed(2)}) | Zoom: ${zoomLevel.toFixed(2)} | Tool: ${activeTool}`;
    }
}

function handleEraserTool(event) {
    const pos = getMousePos(event);
    const snappedPos = snapToGrid(pos.x, pos.y);
    const tileToDelete = findClickedTileInLayer(snappedPos, activeLayerIndex);
    
    if (tileToDelete) {
        deleteTile(activeLayerIndex, tileToDelete);
    }
}

// Make sure these functions are defined elsewhere in your code:
// getMousePos, snapToGrid, findClickedTileInLayer, deleteTile

        canvas.addEventListener('mouseup', function() {
            isDragging = false;
            if (activeTool === 'select' && selectedTile) {
                const snappedPos = snapToGrid(selectedTile.item.x, selectedTile.item.y);
                selectedTile.item.x = snappedPos.x;
                selectedTile.item.y = snappedPos.y;
                redrawCanvas();
            } else if (activeTool === 'marquee') {
                handleMarqueeSelection();
            }
        });

        canvas.addEventListener('dblclick', function(event) {
            const pos = getMousePos(event);
            const clickedTile = findClickedTile(pos);
            
            if (clickedTile) {
                showContextMenu(event.clientX, event.clientY, clickedTile);
            }
        });

        canvas.addEventListener('wheel', function(event) {
    event.preventDefault();
    const zoomFactor = event.deltaY > 0 ? 0.9 : 1.1;
    const mouseX = event.clientX - canvas.offsetLeft;
    const mouseY = event.clientY - canvas.offsetTop;
    
    const oldZoom = zoomLevel;
    zoomLevel *= zoomFactor;
    zoomLevel = Math.min(Math.max(zoomLevel, 0.1), 10);

    // Adjust pan offset to zoom towards mouse position
    panOffset.x = mouseX - (mouseX - panOffset.x) * (zoomLevel / oldZoom);
    panOffset.y = mouseY - (mouseY - panOffset.y) * (zoomLevel / oldZoom);

    redrawCanvas();

    // Update last known mouse position
    lastX = event.clientX;
    lastY = event.clientY;
});

function placeTile(x, y) {
    if (!activeSprite) return;

    const layer = layers[activeLayerIndex];
    if (layer.locked) return;

    // Save state before modifying
    saveState();

    // Check if a tile already exists at this position
    const existingTileIndex = layer.items.findIndex(item => item.x === x && item.y === y);

    const newTile = {
        x: x,
        y: y,
        image: activeSprite.image
    };

    if (existingTileIndex !== -1) {
        // Replace existing tile
        layer.items[existingTileIndex] = newTile;
    } else {
        // Add new tile
        layer.items.push(newTile);
    }

    redrawCanvas();
    saveState();
}

        function findClickedTile(pos) {
            const snappedPos = snapToGrid(pos.x, pos.y);
            for (let i = layers.length - 1; i >= 0; i--) {
                const layer = layers[i];
                if (layer.visible && !layer.locked) {
                    for (let j = layer.items.length - 1; j >= 0; j--) {
                        const item = layer.items[j];
                        if (snappedPos.x === item.x && snappedPos.y === item.y) {
                            return { item: item, layerIndex: i };
                        }
                    }
                }
            }
            return null;
        }

        // function handleEraserTool(event) {
        //     const pos = getMousePos(event);
        //     const snappedPos = snapToGrid(pos.x, pos.y);
        //     const tileToDelete = findClickedTileInLayer(snappedPos, activeLayerIndex);
            
        //     if (tileToDelete) {
        //         deleteTile(activeLayerIndex, tileToDelete);
        //         redrawCanvas();
        //     }
        // }

        function findClickedTileInLayer(pos, layerIndex) {
            const layer = layers[layerIndex];
            return layer.items.find(item => 
                pos.x >= item.x && pos.x < item.x + item.image.width &&
                pos.y >= item.y && pos.y < item.y + item.image.height
            );
        }

        function deleteTile(layerIndex, tile) {
            saveState(); // Save state before modifying
            const layer = layers[layerIndex];
            const index = layer.items.findIndex(item => item.x === tile.x && item.y === tile.y);
            if (index !== -1) {
                layer.items.splice(index, 1);
                if (selectedTile === tile) {
                    selectedTile = null;
                }
            }
            redrawCanvas();
        }

        function floodFill(startX, startY) {
            if (!activeSprite) return;

            const targetLayer = layers[activeLayerIndex];
            if (!targetLayer) return;

            const startPos = snapToGrid(startX, startY);
            const startTile = findClickedTile({ x: startPos.x, y: startPos.y });

            if (startTile && startTile.layerIndex !== activeLayerIndex) return;

            const isUnrestrictedLayer = targetLayer.name === 'Background' || targetLayer.name === 'Blueprints';
            const visited = new Set();
            const toFill = [[startPos.x, startPos.y]];
            const originalTileImage = startTile ? startTile.item.image : null;

            const visibleBounds = getVisibleBounds();

            while (toFill.length > 0) {
                const [x, y] = toFill.pop();
                const key = `${x},${y}`;

                if (visited.has(key)) continue;
                visited.add(key);

                if (!isWithinBounds(x, y, visibleBounds)) continue;

                if (!isUnrestrictedLayer && !isInMarqueeSelection(x, y)) continue;

                const currentTile = findClickedTileInLayer({ x, y }, activeLayerIndex);
                if (currentTile && currentTile.image !== originalTileImage) continue;

                placeTile(x, y);

                [[0, -1], [1, 0], [0, 1], [-1, 0]].forEach(([dx, dy]) => {
                    const newX = x + dx * gridSize;
                    const newY = y + dy * gridSize;
                    toFill.push([newX, newY]);
                });
            }

            redrawCanvas();
        }

        function highlightTile(event) {
  const grid = document.getElementById('grid');
  const tileWidth = gridSize;
  const tileHeight = gridSize;
  const x = Math.floor(event.clientX / tileWidth);
  const y = Math.floor(event.clientY / tileHeight);
  const tile = grid.children[y].children[x];

  // Remove any existing highlight
  const highlightedTile = document.querySelector('.highlight');
  if (highlightedTile) {
    highlightedTile.classList.remove('highlight');
  }

  // Add the highlight to the current tile
  tile.classList.add('highlight');
}

        function getVisibleBounds() {
            const canvasRect = canvas.getBoundingClientRect();
            const topLeft = getMousePos({ clientX: canvasRect.left, clientY: canvasRect.top });
            const bottomRight = getMousePos({ clientX: canvasRect.right, clientY: canvasRect.bottom });

            return {
                left: Math.floor(topLeft.x / gridSize) * gridSize,
                top: Math.floor(topLeft.y / gridSize) * gridSize,
                right: Math.ceil(bottomRight.x / gridSize) * gridSize,
                bottom: Math.ceil(bottomRight.y / gridSize) * gridSize
            };
        }

        function isWithinBounds(x, y, bounds) {
            return x >= bounds.left && x < bounds.right && y >= bounds.top && y < bounds.bottom;
        }

        function isInMarqueeSelection(x, y) {
            if (!marqueeStart || !marqueeEnd || selectedTiles.length === 0) return true;

            const startX = Math.min(marqueeStart.x, marqueeEnd.x);
            const startY = Math.min(marqueeStart.y, marqueeEnd.y);
            const endX = Math.max(marqueeStart.x, marqueeEnd.x);
            const endY = Math.max(marqueeStart.y, marqueeEnd.y);

            return x >= startX && x < endX && y >= startY && y < endY;
        }

        // More functions will follow in the next part...
        function showContextMenu(x, y, clickedTile) {
            const existingMenu = document.querySelector('.context-menu');
            if (existingMenu) {
                existingMenu.remove();
            }

            const contextMenu = document.createElement('div');
            contextMenu.className = 'context-menu';
            contextMenu.style.left = `${x}px`;
            contextMenu.style.top = `${y}px`;

            const actions = ['Rotate', 'Flip Horizontal', 'Flip Vertical', 'Delete'];
            actions.forEach(action => {
                const item = document.createElement('div');
                item.className = 'context-menu-item';
                item.textContent = action;
                item.addEventListener('click', () => {
                    switch(action) {
                        case 'Rotate':
                            rotateTile(clickedTile.item);
                            break;
                        case 'Flip Horizontal':
                            flipTileHorizontal(clickedTile.item);
                            break;
                        case 'Flip Vertical':
                            flipTileVertical(clickedTile.item);
                            break;
                        case 'Delete':
                            deleteTile(clickedTile.layerIndex, clickedTile.item);
                            break;
                    }
                    contextMenu.remove();
                    redrawCanvas();
                });
                contextMenu.appendChild(item);
            });

            document.body.appendChild(contextMenu);

            document.addEventListener('click', function closeMenu(e) {
                if (!contextMenu.contains(e.target)) {
                    contextMenu.remove();
                    document.removeEventListener('click', closeMenu);
                }
            });
        }

        function rotateTile(tile) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = tile.image.height;
            tempCanvas.height = tile.image.width;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
            tempCtx.rotate(Math.PI / 2);
            tempCtx.drawImage(tile.image, -tile.image.width / 2, -tile.image.height / 2);
            tile.image = tempCanvas;
        }

        function flipTileHorizontal(tile) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = tile.image.width;
            tempCanvas.height = tile.image.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.scale(-1, 1);
            tempCtx.drawImage(tile.image, -tile.image.width, 0);
            tile.image = tempCanvas;
        }

        function flipTileVertical(tile) {
            const tempCanvas = document.createElement('canvas');
            tempCanvas.width = tile.image.width;
            tempCanvas.height = tile.image.height;
            const tempCtx = tempCanvas.getContext('2d');
            tempCtx.scale(1, -1);
            tempCtx.drawImage(tile.image, 0, -tile.image.height);
            tile.image = tempCanvas;
        }

        function handleMarqueeSelection() {
            if (!marqueeStart || !marqueeEnd) return;

            selectedTiles = [];
            const startX = Math.min(marqueeStart.x, marqueeEnd.x);
            const startY = Math.min(marqueeStart.y, marqueeEnd.y);
            const endX = Math.max(marqueeStart.x, marqueeEnd.x);
            const endY = Math.max(marqueeStart.y, marqueeEnd.y);

            layers.forEach((layer, layerIndex) => {
                if (layer.visible && !layer.locked) {
                    layer.items.forEach(tile => {
                        if (tile.x >= startX && tile.x < endX && tile.y >= startY && tile.y < endY) {
                            selectedTiles.push({ layerIndex, tile });
                        }
                    });
                }
            });

            console.log(`Selected ${selectedTiles.length} tiles`);
            marqueeStart = null;
            marqueeEnd = null;
            redrawCanvas();
        }

        function drawMarqueeSelection() {
            if (!marqueeStart || !marqueeEnd) return;

            ctx.save();
            ctx.setLineDash([5, 5]);
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
            ctx.lineWidth = 2 / zoomLevel;
            ctx.beginPath();
            
            const startX = Math.min(marqueeStart.x, marqueeEnd.x);
            const startY = Math.min(marqueeStart.y, marqueeEnd.y);
            const width = Math.abs(marqueeEnd.x - marqueeStart.x);
            const height = Math.abs(marqueeEnd.y - marqueeStart.y);
            
            ctx.rect(startX, startY, width, height);
            ctx.stroke();
            ctx.restore();
        }

        function highlightSelectedTiles() {
            ctx.save();
            ctx.strokeStyle = 'rgba(0, 255, 0, 0.8)';
            ctx.lineWidth = 2 / zoomLevel;
            selectedTiles.forEach(({ tile }) => {
                ctx.strokeRect(tile.x, tile.y, tile.image.width, tile.image.height);
            });
            ctx.restore();
        }

        // function placeLightSource(pos) {
        //     const snappedPos = snapToGrid(pos.x, pos.y);
        //     lightSources.push({ x: snappedPos.x, y: snappedPos.y });
        // }

        function placeLightSource(event) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = (event.clientX - rect.left - panOffset.x) / zoomLevel;
    const mouseY = (event.clientY - rect.top - panOffset.y) / zoomLevel;

    const snappedPos = snapToGrid(mouseX, mouseY);
    const newLightSource = { 
        x: snappedPos.x + gridSize / 2, 
        y: snappedPos.y + gridSize / 2 
    };

    lightSources.push(newLightSource);
    redrawCanvas();
}

    // // Update debug label -- ^^^ was in here
    // const debugLabel = document.getElementById('debug-label');
    // if (debugLabel) {
    //     debugLabel.textContent = `Light ${event.shiftKey ? 'removed' : 'placed'} at: (${snappedPos.x}, ${snappedPos.y})`;
    // }
// }

        function showSettingsModal() {
            const settingsHtml = `
                <div id="settings-modal" class="modal">
                    <div class="modal-content">
                        <h4>Settings</h4>
                        <div>
                            <label for="grid-size">Grid Size:</label>
                            <input type="number" id="grid-size" value="${gridSize}" min="1">
                        </div>
                        <div>
                            <label>
                                <input type="checkbox" id="visibility-behavior" ${useOpacityForHiddenLayers ? 'checked' : ''}>
                                Use opacity for hidden layers
                            </label>
                        </div>
                    </div>
                    <div class="modal-footer">
                        <a href="#!" class="modal-close waves-effect waves-green btn-flat">Cancel</a>
                        <a href="#!" class="modal-close waves-effect waves-green btn-flat" id="save-settings">Save</a>
                    </div>
                </div>
            `;
            
            const settingsElement = document.createElement('div');
            settingsElement.innerHTML = settingsHtml;
            document.body.appendChild(settingsElement);

            const settingsModal = M.Modal.init(document.getElementById('settings-modal'));
            settingsModal.open();

            document.getElementById('save-settings').addEventListener('click', function() {
                gridSize = parseInt(document.getElementById('grid-size').value);
                useOpacityForHiddenLayers = document.getElementById('visibility-behavior').checked;
                redrawCanvas();
            });
        }

        function addNewLayer() {
    // Prompt for layer name with a default value
    let name = prompt('Enter layer name:', `Layer ${layers.length + 1}`);
    
    // If user cancels the prompt, name will be null
    if (name === null) {
        return; // Exit the function without creating a layer
    }

    // If user entered an empty string, use the default name
    if (name.trim() === '') {
        name = `Layer ${layers.length + 1}`;
    }

    // Save state before modifying
    saveState();

    // Create the new layer
    const newLayer = {
        name: name,
        color: getRandomColor(),
        visible: true,
        locked: false,
        items: [],
        order: layers.length
    };

    // Add the new layer
    layers.push(newLayer);

    // Update the layer list in the UI
    updateLayerList();

    // Set the new layer as the active layer
    setActiveLayer(layers.length - 1);

    // Redraw the canvas to reflect changes
    redrawCanvas();

    // Optionally, you could save state again here if you want the layer selection to be a separate undoable action
    // saveState();
}

        // More functions will follow in the next part...
        function saveProject() {
            const mapData = {
                layers: layers,
                gridSize: gridSize,
                zoomLevel: zoomLevel,
                panOffset: panOffset,
                lightSources: lightSources
            };
            const mapDataString = JSON.stringify(mapData);
            const blob = new Blob([mapDataString], {type: 'application/json'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tilemap_project.json';
            a.click();
            URL.revokeObjectURL(url);
        }

        function loadProject() {
            const input = document.createElement('input');
            input.type = 'file';
            input.accept = '.json';
            input.onchange = function(event) {
                const file = event.target.files[0];
                const reader = new FileReader();
                reader.onload = function(e) {
                    const mapData = JSON.parse(e.target.result);
                    layers = mapData.layers;
                    gridSize = mapData.gridSize;
                    zoomLevel = mapData.zoomLevel;
                    panOffset = mapData.panOffset;
                    lightSources = mapData.lightSources || [];
                    updateLayerList();
                    redrawCanvas();
                };
                reader.readAsText(file);
            };
            input.click();
        }

        function saveTilesheet() {
    if (!sprites.length) {
        alert('No sprites to save. Please load and slice a spritesheet first.');
        return;
    }

    const zip = new JSZip();
    const infoFile = new Blob([JSON.stringify({
        gridWidth: parseInt(document.getElementById('sprite-width').value),
        gridHeight: parseInt(document.getElementById('sprite-height').value)
    })], {type: 'application/json'});
    zip.file('tilesheet_info.json', infoFile);

    sprites.forEach((sprite, index) => {
        zip.file(`sprite_${index}.png`, dataURLtoBlob(sprite.image.toDataURL()), {base64: true});
    });

    zip.generateAsync({type: 'blob'})
        .then(function(content) {
            const url = URL.createObjectURL(content);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'sliced_tilesheet.zip';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        });
}

function updateGridSizeAndSliceSpritesheet() {
  const width = parseInt(document.getElementById('sprite-width').value);
  const height = parseInt(document.getElementById('sprite-height').value);

  if (width === height) {
    gridSize = width;
  }
  sliceSpritesheet();
}

function loadTilesheet() {
    // Check if JSZip is available
    if (typeof JSZip === 'undefined') {
        console.error('JSZip library is not loaded. Make sure it\'s included in your HTML file.');
        alert('Unable to load tilesheet. JSZip library is missing.');
        return;
    }

    const input = document.createElement('input');
    input.type = 'file';
    input.accept = '.zip';
    input.onchange = function(event) {
        const file = event.target.files[0];
        if (!file) {
            console.log('No file selected');
            return;
        }
        console.log('File selected:', file.name);

        const reader = new FileReader();
        reader.onload = function(e) {
            console.log('File read successfully');
            JSZip.loadAsync(e.target.result).then(function(zip) {
                console.log('ZIP file loaded successfully');
                return zip.file('tilesheet_info.json').async('string');
            }).then(function(infoContent) {
                console.log('tilesheet_info.json content:', infoContent);
                const info = JSON.parse(infoContent);
                document.getElementById('sprite-width').value = info.gridWidth;
                document.getElementById('sprite-height').value = info.gridHeight;
                gridSize = info.gridWidth; // Assuming square tiles
                
                sprites = [];
                const spritePromises = [];
                zip.forEach(function(relativePath, zipEntry) {
                    if (relativePath.startsWith('sprite_') && relativePath.endsWith('.png')) {
                        console.log('Processing sprite:', relativePath);
                        const promise = zipEntry.async('base64').then(function(content) {
                            return new Promise((resolve) => {
                                const img = new Image();
                                img.onload = function() {
                                    const canvas = document.createElement('canvas');
                                    canvas.width = img.width;
                                    canvas.height = img.height;
                                    const ctx = canvas.getContext('2d');
                                    ctx.drawImage(img, 0, 0);
                                    sprites.push({
                                        name: relativePath.split('.')[0],
                                        image: canvas
                                    });
                                    console.log('Sprite loaded:', relativePath);
                                    resolve();
                                };
                                img.onerror = function() {
                                    console.error('Failed to load image:', relativePath);
                                    resolve();
                                };
                                img.src = 'data:image/png;base64,' + content;
                            });
                        });
                        spritePromises.push(promise);
                    }
                });

                return Promise.all(spritePromises);
            }).then(function() {
                console.log('All sprites loaded. Total sprites:', sprites.length);
                updateSpriteList();
                redrawCanvas();
                console.log('Sprite list updated and canvas redrawn');
            }).catch(function(error) {
                console.error('Error loading tilesheet:', error);
                alert('Error loading tilesheet: ' + error.message);
            });
        };
        reader.onerror = function(error) {
            console.error('Error reading file:', error);
            alert('Error reading file: ' + error.message);
        };
        reader.readAsArrayBuffer(file);
    };
    input.click();
}

function dataURLtoBlob(dataurl) {
    var arr = dataurl.split(','), mime = arr[0].match(/:(.*?);/)[1],
        bstr = atob(arr[1]), n = bstr.length, u8arr = new Uint8Array(n);
    while(n--){
        u8arr[n] = bstr.charCodeAt(n);
    }
    return new Blob([u8arr], {type:mime});
}

        function addDungeonGenerationButton() {
            const dungeonBtn = document.createElement('i');
            dungeonBtn.className = 'material-icons tool-button';
            dungeonBtn.title = 'Generate Dungeon';
            dungeonBtn.textContent = 'door_front';
            dungeonBtn.style.color = 'black';
            dungeonBtn.addEventListener('click', openDungeonDialog);
            document.getElementById('toolbox').appendChild(dungeonBtn);
        }

        function openDungeonDialog() {
  const dialogHtml = `
        <div id="dungeon-dialog" class="modal">
            <div class="modal-content">
                <h4>Generate Dungeon</h4>
                <div class="input-field">
                    <input type="number" id="dungeon-width" value="20" min="10" max="100">
                    <label for="dungeon-width">Dungeon Width (in tiles)</label>
                </div>
                <div class="input-field">
                    <input type="number" id="dungeon-height" value="20" min="10" max="100">
                    <label for="dungeon-height">Dungeon Height (in tiles)</label>
                </div>
                <div class="input-field">
                    <input type="number" id="room-count" value="5" min="1" max="20">
                    <label for="room-count">Number of Rooms</label>
                </div>
                <div id="tile-chooser">
                    <h5>Choose Tiles</h5>
                    <div class="tile-selector-row">
                        <div class="tile-selector">
                            <label>Floor Tile</label>
                            <div class="tile-carousel">
                                <button class="prev-tile">&lt;</button>
                                <div id="floor-tile-preview" class="tile-preview"></div>
                                <button class="next-tile">&gt;</button>
                            </div>
                        </div>
                        <div class="tile-selector">
                            <label>Wall Tile</label>
                            <div class="tile-carousel">
                                <button class="prev-tile">&lt;</button>
                                <div id="wall-tile-preview" class="tile-preview"></div>
                                <button class="next-tile">&gt;</button>
                            </div>
                        </div>
                        <div class="tile-selector">
                            <label>Door Tile</label>
                            <div class="tile-carousel">
                                <button class="prev-tile">&lt;</button>
                                <div id="door-tile-preview" class="tile-preview"></div>
                                <button class="next-tile">&gt;</button>
                            </div>
                        </div>
                        <div class="tile-selector">
                            <label>Corridor Tile</label>
                            <div class="tile-carousel">
                                <button class="prev-tile">&lt;</button>
                                <div id="corridor-tile-preview" class="tile-preview"></div>
                                <button class="next-tile">&gt;</button>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
            <div class="modal-footer">
                <a href="#!" class="modal-close waves-effect waves-green btn-flat">Cancel</a>
                <a href="#!" class="waves-effect waves-green btn-flat" id="generate-dungeon">Generate</a>
            </div>
        </div>
    `;

  const dialogElement = document.createElement('div');
  dialogElement.innerHTML = dialogHtml;
  document.body.appendChild(dialogElement);

  // Add styles for tile previews and carousel
  const style = document.createElement('style');
  style.textContent = `
        #dungeon-dialog .modal-content {
            max-height: 80vh;
            overflow-y: auto;
        }
        .tile-selector-row {
            display: flex;
            justify-content: space-between;
            flex-wrap: wrap;
        }
        .tile-selector {
            flex: 1 1 auto;
            min-width: 120px;
            margin: 0 10px 20px;
            text-align: center;
        }
        .tile-carousel {
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tile-preview {
            width: 64px;
            height: 64px;
            border: 1px solid #ccc;
            margin: 0 5px;
            display: flex;
            align-items: center;
            justify-content: center;
        }
        .tile-preview img {
            max-width: 100%;
            max-height: 100%;
            image-rendering: pixelated;
        }
        .prev-tile, .next-tile {
            background: #f0f0f0;
            border: none;
            padding: 5px 10px;
            cursor: pointer;
        }
        @media (max-width: 600px) {
            .tile-selector {
                flex-basis: 100%;
            }
        }
    `;
  document.head.appendChild(style);

  const dungeonDialog = M.Modal.init(document.getElementById('dungeon-dialog'), {
    dismissible: false, // Prevent closing by clicking outside
    endingTop: '10%', // Position the modal a bit higher
  });

  initTileCarousels();

  dungeonDialog.open();

  document.getElementById('generate-dungeon').addEventListener('click', generateDungeon);
}

function initTileCarousels() {
  const tileTypes = ['floor', 'wall', 'door', 'corridor'];
  tileTypes.forEach(type => {
    const preview = document.getElementById(`${type}-tile-preview`);
    const prevBtn = preview.parentElement.querySelector('.prev-tile');
    const nextBtn = preview.parentElement.querySelector('.next-tile');
    let currentIndex = 0;

    function updatePreview() {
      if (sprites.length > 0) {
        const sprite = sprites[currentIndex];
        preview.innerHTML = `<img src="${sprite.image.toDataURL()}" alt="${sprite.name || `Sprite ${currentIndex}`}">`;
        preview.dataset.spriteIndex = currentIndex;
      } else {
        preview.innerHTML = 'No sprites available';
      }
    }

    prevBtn.addEventListener('click', () => {
      currentIndex = (currentIndex - 1 + sprites.length) % sprites.length;
      updatePreview();
    });

    nextBtn.addEventListener('click', () => {
      currentIndex = (currentIndex + 1) % sprites.length;
      updatePreview();
    });

    updatePreview();
  });
}

function populateTileChoosers() {
  const tileSelects = ['floor-tile', 'wall-tile', 'door-tile', 'corridor-tile'];
  tileSelects.forEach(selectId => {
    const select = document.getElementById(selectId);
    if (!select) {
      console.error(`Select element with id "${selectId}" not found`);
      return;
    }
    select.innerHTML = '';
    if (sprites.length === 0) {
      console.warn('No sprites available for tile chooser');
      const option = document.createElement('option');
      option.textContent = 'No sprites available';
      select.appendChild(option);
    } else {
      sprites.forEach((sprite, index) => {
        const option = document.createElement('option');
        option.value = index;
        option.textContent = sprite.name || `Sprite ${index}`;
        select.appendChild(option);
      });
    }

    // Add change event listener to update preview
    select.addEventListener('change', (event) => {
      const selectedIndex = event.target.value;
      const selectedSprite = sprites[selectedIndex];
      const previewContainer = document.createElement('div');
      previewContainer.innerHTML = `<strong>Selected ${selectId.replace('-tile', '')} tile:</strong><br>`;
      const preview = document.createElement('img');
      preview.src = selectedSprite.image.toDataURL();
      preview.style.width = '64px';
      preview.style.height = '64px';
      preview.style.imageRendering = 'pixelated';
      previewContainer.appendChild(preview);

      const existingPreview = select.parentNode.querySelector('.tile-preview-container');
      if (existingPreview) {
        existingPreview.remove();
      }
      previewContainer.classList.add('tile-preview-container');
      select.parentNode.appendChild(previewContainer);
    });
  });

  // Initialize Materialize select
  M.FormSelect.init(document.querySelectorAll('select'));

  console.log('Tile choosers populated:', sprites.length, 'sprites available');
}

function updateTileChoosers() {
  const dungeonDialog = document.getElementById('dungeon-dialog');
  if (dungeonDialog) {
    initTileCarousels();
  }
}

function generateDungeon() {
  const width = parseInt(document.getElementById('dungeon-width').value);
  const height = parseInt(document.getElementById('dungeon-height').value);
  const roomCount = parseInt(document.getElementById('room-count').value);
  const floorTile = sprites[document.getElementById('floor-tile-preview').dataset.spriteIndex];
  const wallTile = sprites[document.getElementById('wall-tile-preview').dataset.spriteIndex];
  const doorTile = sprites[document.getElementById('door-tile-preview').dataset.spriteIndex];
  const corridorTile = sprites[document.getElementById('corridor-tile-preview').dataset.spriteIndex];

  // Create a 2D array to represent the dungeon
  const dungeon = Array(height).fill().map(() => Array(width).fill(0));

  // Generate rooms
  const rooms = [];
  for (let i = 0; i < roomCount; i++) {
    const roomWidth = Math.floor(Math.random() * 5) + 5;
    const roomHeight = Math.floor(Math.random() * 5) + 5;
    const x = Math.floor(Math.random() * (width - roomWidth - 2)) + 1;
    const y = Math.floor(Math.random() * (height - roomHeight - 2)) + 1;

    rooms.push({
      x,
      y,
      width: roomWidth,
      height: roomHeight
    });

    // Fill room with floor tiles
    for (let dy = 0; dy < roomHeight; dy++) {
      for (let dx = 0; dx < roomWidth; dx++) {
        dungeon[y + dy][x + dx] = 1;
      }
    }
  }

  // Connect rooms with corridors
  for (let i = 0; i < rooms.length - 1; i++) {
    const roomA = rooms[i];
    const roomB = rooms[i + 1];
    const pointA = {
      x: roomA.x + Math.floor(roomA.width / 2),
      y: roomA.y + Math.floor(roomA.height / 2)
    };
    const pointB = {
      x: roomB.x + Math.floor(roomB.width / 2),
      y: roomB.y + Math.floor(roomB.height / 2)
    };

    // Create L-shaped corridor
    while (pointA.x !== pointB.x) {
      dungeon[pointA.y][pointA.x] = 2;
      pointA.x += pointA.x < pointB.x ? 1 : -1;
    }
    while (pointA.y !== pointB.y) {
      dungeon[pointA.y][pointA.x] = 2;
      pointA.y += pointA.y < pointB.y ? 1 : -1;
    }
  }

  // Add walls around rooms and corridors
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      if (dungeon[y][x] === 0 && hasAdjacentFloor(dungeon, x, y)) {
        dungeon[y][x] = 3;
      }
    }
  }

  // Place dungeon on the canvas
  for (let y = 0; y < height; y++) {
    for (let x = 0; x < width; x++) {
      let tile;
      switch (dungeon[y][x]) {
        case 1:
          tile = floorTile;
          break;
        case 2:
          tile = corridorTile;
          break;
        case 3:
          tile = wallTile;
          break;
        default:
          continue;
      }
      layers[activeLayerIndex].items.push({
        image: tile.image,
        x: x * gridSize,
        y: y * gridSize
      });
    }
  }

  // Place doors
  rooms.forEach(room => {
    const doorX = room.x + Math.floor(room.width / 2);
    const doorY = room.y + room.height - 1;
    if (doorY < height - 1 && dungeon[doorY + 1][doorX] === 2) {
      layers[activeLayerIndex].items.push({
        image: doorTile.image,
        x: doorX * gridSize,
        y: doorY * gridSize
      });
    }
  });

  redrawCanvas();
  M.Modal.getInstance(document.getElementById('dungeon-dialog')).close();
}

function hasAdjacentFloor(dungeon, x, y) {
  const directions = [
    [-1, 0],
    [1, 0],
    [0, -1],
    [0, 1]
  ];
  return directions.some(([dx, dy]) => {
    const nx = x + dx;
    const ny = y + dy;
    return nx >= 0 && nx < dungeon[0].length && ny >= 0 && ny < dungeon.length && (dungeon[ny][nx] === 1 || dungeon[ny][nx] === 2);
  });
}



function bindEventListeners() {
    const elementIds = [
        'spritesheet-btn', 'sprite-width', 'sprite-height', 'grid-offset-x', 'grid-offset-y',
        'tile-count-width', 'tile-count-height', // Add these new IDs
        'spritesheet-ok', 'add-layer-btn', 'save-btn', 'load-btn', 'save-tilesheet-btn',
        'load-tilesheet-btn', 'settings-btn', 'help-btn'
    ];
    elementIds.forEach(id => {
        const element = document.getElementById(id);
        if (element) {
            switch (id) {
                case 'spritesheet-btn':
                    element.addEventListener('click', handleSpritesheet);
                    break;
                case 'sprite-width':
                case 'sprite-height':
                case 'grid-offset-x':
                case 'grid-offset-y':
                case 'tile-count-width':
                case 'tile-count-height':
                    element.addEventListener('change', drawSpritesheetGrid);
                    break;
                case 'spritesheet-ok':
                    element.addEventListener('click', updateGridSizeAndSliceSpritesheet);
                    break;
                case 'add-layer-btn':
                    element.addEventListener('click', addNewLayer);
                    break;
                case 'save-btn':
                    element.addEventListener('click', saveProject);
                    break;
                case 'load-btn':
                    element.addEventListener('click', loadProject);
                    break;
                case 'save-tilesheet-btn':
                    element.addEventListener('click', saveTilesheet);
                    break;
                case 'load-tilesheet-btn':
                    element.addEventListener('click', loadTilesheet);
                    break;
                case 'settings-btn':
                    element.addEventListener('click', showSettingsModal);
                    break;
                case 'help-btn':
                    element.addEventListener('click', function() {
                        const helpModal = M.Modal.init(document.getElementById('help-modal'));
                        helpModal.open();
                    });
                    break;
            }
            console.log(`Event listener added for ${id}`);
        } else {
            console.error(`Element with id '${id}' not found`);
        }
    });

    document.addEventListener('keydown', function(event) {
    if (event.ctrlKey || event.metaKey) { // Ctrl for Windows/Linux, Cmd for Mac
        switch (event.key) {
            case 'z':
                event.preventDefault();
                undo();
                break;
            case 'y':
                event.preventDefault();
                redo();
                break;
            case 'Z':
                event.preventDefault();
                redo(); // Shift+Ctrl+Z is often used as an alternative redo shortcut
                break;
        }
    }
});

    document.getElementById('layer-panel').addEventListener('mousemove', updateDebugLabel);

    const grid = document.getElementById(gridId);
    if (grid) {
        grid.addEventListener('mousemove', highlightTile);
    } else {
        console.error(`Grid element with ID ${gridId} not found`);
    }

    document.querySelectorAll('.tool-button').forEach(button => {
        button.addEventListener('click', function() {
            activeTool = this.getAttribute('data-tool');
            updateToolHighlight();
        });
    });

    document.getElementById('undo-btn').addEventListener('click', undo);
document.getElementById('redo-btn').addEventListener('click', redo);

    window.addEventListener('resize', function() {
        resizeCanvas();
        redrawCanvas();
    });
}

    // Initialize the application
    init();
});
  </script>
 </body>
</html>
